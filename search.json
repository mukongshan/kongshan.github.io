[{"title":"Java变成学习笔记","url":"/2025/11/26/Java%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/","content":"基础Java生命周期\n编码阶段（Writing Code）\n\n\n开发者编写源代码，文件后缀为 .java。比如：HelloWorld.java。\n源代码中包含类（class）、方法（method）等，使用 Java 语法。\n\n\n\n编译阶段（Compiling）\n\n\n使用 Java 编译器 javac 将 .java 文件编译成 字节码文件（.class）。\njavac HelloWorld.java\n\n编译后生成 HelloWorld.class 文件。\n\n注意：字节码不是机器码，而是一种中间形式，跨平台。\n\n\n\n\n类加载阶段（Class Loading）\n\n\n当运行程序时（java HelloWorld），类加载器（ClassLoader） 会把需要的 .class 文件加载进内存。\n类加载过程分为三个小步骤：\n加载（Loading）：把字节码读到内存。\n连接（Linking）：包括验证（验证字节码合法性）、准备（为静态变量分配内存）、解析（符号引用替换为直接引用）。\n初始化（Initialization）：执行静态代码块、给静态变量赋初值。\n\n\n\n\n\n字节码执行阶段（Execution）\n\n\nJava 虚拟机（JVM）解释执行字节码，也可能使用 JIT（即时编译器） 把热点代码编译成本地机器码，以提高运行效率。\n\n执行的起点是程序入口：\npublic static void main(String[] args) &#123; ... &#125;\n\n\n\n程序运行时（Runtime）\n\n\nJVM 在运行时会：\n内存管理：使用 堆、栈、方法区、运行时常量池 等。\n垃圾回收（GC）：回收不再使用的对象内存。\n异常处理：执行过程中出现异常时，JVM 按照异常机制处理。\n\n\n\n\n\n程序终止（Termination）\n\n\n当 main 方法执行完毕，且所有非守护线程（non-daemon thread）都结束时，JVM 退出。\n在退出前，可能会执行 finally 块、shutdown hook（关闭钩子）。\n\n\n程序生命\n\n$$.java(源码) \\underset{\\text{decompile}}{\\overset{\\text{compile}}{\\longleftrightarrow}} .class(字节码)\\xrightarrow{\\text{load}}class类\\xrightarrow{\\text{execution}}机器码\\xrightarrow{\\text{run}}结果$$\nJVM, JRE, JDK的关系\n\n\n\n名称\n全称\n作用\n是否包含编译器\n是否必需开发 Java 程序\n说明\n\n\n\nJVM\nJava Virtual Machine（Java 虚拟机）\n运行 Java 字节码的虚拟计算机，负责加载字节码并执行\n❌ 不包含\n❌ 不单独用于开发\n是运行 Java 程序的“引擎”\n\n\nJRE\nJava Runtime Environment（Java 运行时环境）\n运行 Java 程序所需的环境，包含 JVM + 核心类库\n❌ 不包含\n❌ 仅能运行，不能开发\n如果你只需要运行 Java 程序（比如别人的软件），安装 JRE 就够了\n\n\nJDK\nJava Development Kit（Java 开发工具包）\n开发 Java 程序所需的完整工具包，包含 JRE + 编译器（javac） + 调试工具等\n✅ 包含（javac）\n✅ 必需\n开发 Java 程序必须安装 JDK\n\n\n编译字节码（.class文件）\n.class文件是 Java 源代码（.java）经过 javac编译后生成的字节码文件，它是 平台无关的中间代码，不能直接被操作系统执行，但可以被 Java 虚拟机（JVM）加载和执行。\n\n文件结构ClassFile &#123;    u4             magic; // 魔数CAFEBABY，仅代表这个文件是java文件，没有其他作用    u2             minor_version; // 副版本号    u2             major_version; // 主版本号    u2             constant_pool_count;         // 常量池大小    cp_info        constant_pool[constant_pool_count-1]; // 常量池    u2             access_flags;                // 访问标志(public, private)    u2             this_class; // 指向当前类，是cp_info的下标    u2             super_class; // 指向父类    u2             interfaces_count;     u2             interfaces[interfaces_count]; // 接口信息    u2             fields_count;                     field_info     fields[fields_count]; // 字段信息    u2             methods_count;                   method_info    methods[methods_count]; // 方法信息    u2             attributes_count;                attribute_info attributes[attributes_count]; // 属性信息&#125;\n\ncp_infocp_info&#123;\tu1 tag;\tu1 info[]; // 大小是可变的。例如Integer就是u4 byte, String就是u2 length, u1 byte[length]。&#125;\n\n\ntag的取值表：\nthis_class指向CONSTANT_Class_Info，后者又指向一个字符串(name)。\n\nfield_infofield_info &#123;    u2             access_flags;    u2             name_index; // 本质是个下标，指向常量池    u2             descriptor_index;    u2             attributes_count;    attribute_info attributes[attributes_count];&#125;\n\n\naccess_flag的取值：字段可以叠加，Value取或\n\nmethod_infomethod_info &#123;    u2             access_flags;    u2             name_index;    u2             descriptor_index;    u2             attributes_count;    attribute_info attributes[attributes_count];&#125;\n\n描述符\n规范：前缀+类完整名（包含分号）（如果不是以下的基本类型）\n\n前缀：\n1. \n\n\n\n\nJava 类型\n描述符\n说明\n\n\n\nbyte\nB\n8-bit 整数\n\n\nchar\nC\n16-bit Unicode 字符\n\n\ndouble\nD\n64-bit 双精度浮点数\n\n\nfloat\nF\n32-bit 单精度浮点数\n\n\nint\nI\n32-bit 整数\n\n\nlong\nJ\n64-bit 整数\n\n\nshort\nS\n16-bit 整数\n\n\nboolean\nZ\n布尔类型（true&#x2F;false）\n\n\nvoid\nV\n仅用于返回类型，表示无返回\n\n\narray\n[\n表示返回数组\n\n\n\n\n\n入参的表示：用小括号包裹。\n\n例\nint func(String s) --&gt; &lt;(Ljava/lang/String;)I&gt;,   void func() --&gt; &lt;()V&gt;,  float func(double[] d ) --&gt; &lt;([D)F&gt;\n\nattributes\n属性太多了，这里仅介绍几个常见的\n\n\nConstantValue：只针对常量static final的基础类型或字符串的属性，在编译器赋值，而不是运行时，提高效率。\nCode：函数体的内容，这个是非常重要的，尤其是后面学习ASM指令，一个类主要承载的功能，都反应在了method的code里。\nException：函数中声明的抛出的异常，可以有多个。注意这里是声明的抛出的异常，不包含一些运行时的异常。\n区分Code异常表和Exception属性：通过try-catch的异常会出现在code异常表。\n\n\nLineNumberTable\nLocalVariableTable\nSignature：与泛型密切相关\n\n函数code中的指令\nload &#x2F; push\n\nload的形式有很多种，比如我们可以把本地变量load到栈顶\niload_{y}按照int或byte或char或boolean或short类型，加载第y个变量。\nlload_{y}按照long类型加载第y个变量。\nfload_{y}按照float类型加载第y个变量。\ndload_{y}按照double类型加载第y个变量。\naload_{y}按照对象类型加载第y个变量，aload_0加载this，默认第0个位置是this或者常量load到栈顶\n\n\nbipush针对byte范围的int值的load\nsipush针对short范围的int值的load\n\n\nstore：理同load\n\nreturn：\n\nreturn之后需要保证栈是空的，不然编译会验证不通过。\n\nreturn等于代码return，不消耗栈顶\nireturn消耗栈顶一帧，返回一个int或byte或char或boolean或short类型\nfreturn消耗栈顶一帧返回一个float\nlreturn消耗栈顶2帧返回一个long\ndreturn消耗栈顶2帧返回一个double\nareturn消耗栈顶一帧返回一个地址，即返回一个对象类型的内存地址\n\n注意：return不一定是代码结束的地方，可能有判断分支有多个return语句，而且还有可能是athrow抛出异常。\n\n\n\npop &#x2F; dup &#x2F; new\n\npop：如果一个栈上的操作数，想要直接消耗掉，则直接用pop指令消耗一个栈帧，比如运行了一个函数操作后，直接忽略函数的返回值就可以pop消耗掉，如果返回值是long/double可以pop两次，或者pop2指令消耗。\ndup：复制栈顶栈帧。用法同pop。这经常用于new一个对象。\nnew的过程：对应字节码，如下new指令作用是，创建一个对象会在堆上分配内存，并将内存的地址放到操作数栈上；注意这里有个dup把地址复制了一份，这是new对象的一个固定操作，因为invokespecial #1 &lt;java/lang/Object.&lt;init&gt; : ()V&gt;这个构造方法与普通非静态方法一样，会消耗掉一个操作数作为this。所以需要提前把地址备份一下，不然new完地址就丢了，下面会说invoke相关指令。\n\n\ninvoke\n\ninvoke是函数调用的指令，他主要有5种，\ninvokevirtual普通的可访问的方法，需要依次把对象，参数从左到右放到栈顶。\ninvokestatic静态方法，需要依次把参数从左到右放到栈顶。\ninvokespecial特殊方法，构造方法，私有方法，父类中的方法，接口的default实现等，根据情况参考上面的操作数顺序。\ninvokeinterface接口方法，栈顶操作数顺序参考上面。\ninvokedynamic动态方法，一般是lambda表达式，栈顶操作数顺序参考上面。\n\n\n\n\n跳转\n\n注意，long &#x2F; double占两个局部变量\n其实try-catch是专门记录到code的异常表中的，上面提到过异常表和异常属性的区别。\n\n\n\n常量池概述\n常量池（Constant Pool）是 Java .class文件中的一个重要组成部分，它是一个结构化的、预定义的常量表，用于存储：字面量（如字符串、数字等），符号引用（如类名、方法名、字段名、方法描述符等），其他在程序运行时或类加载时可能需要引用的常量信息。\n它不是程序运行时动态生成的，也不是只在编译期间临时存在的东西。\n字面量（Literal）如 int a = 1; 里的 1，或者 &quot;Hello&quot; 这样的字符串。\n符号引用（Symbolic Reference）\n类和接口的全限定名（例如 java/lang/String）\n字段名和描述符\n方法名和描述符\n\n\n\n分类\n静态常量池（Class File Constant Pool）\n\n位置：位于 .class 文件中。\n生成时机：编译阶段由编译器写入。\n内容：\n字面量（Literal）\n基本类型常量（如 1.2f, 100）\n字符串字面量（如 &quot;Hello&quot;）\nfinal 常量（编译期可确定的值）\n\n\n符号引用（Symbolic Reference）\n类和接口的全限定名（如 java/lang/String）\n字段名和描述符\n方法名和方法描述符\n\n\n\n\n作用：为类加载时提供原始数据。\n\n注意：静态常量池是“死”的，只存在于 .class 文件里，不会变化。\n\n\n运行时常量池（Runtime Constant Pool）\n\n\n位置：方法区的一部分（JDK 8 之后是元空间 Metaspace 中）。\n\n生成时机：类加载的 加载 → 链接 过程中，JVM 会把 .class 文件中的静态常量池信息拷贝到运行时常量池。\n\n内容：\n\n解析后的字面量（真正的 int、float、String 对象引用）。\n符号引用在 解析（Resolution）阶段 转换为 直接引用（比如指向方法区中某个方法的指针）。\n\n\n特点：\n\n是动态的，可以在运行时产生新的常量，比如 String.intern() 会把字符串放到运行时常量池。\n不仅包含编译期的常量，还包含运行期解析出来的引用。\n\n\n字符串常量池（String Constant Pool）\n\n属于运行时常量池的一部分。但是在堆区中。即逻辑上属于运行时常量池，但是物理上不在一个区。\n专门存放字符串字面量的池子。\n早期（JDK 6 及之前）在方法区，JDK 7 后移到了堆中。\n\n\n\n\n\n字符串常量池\n字符串常量池在堆中，可能存在在E区、S区、O区。在讲解时默认在E区\n\n如果通过字面量赋值，则字符串对象直接出现在常量池中。\n\nString s &#x3D; “lizhi”;\n\n\nString s &#x3D; new String(“lizhi”);\n\n\nString a = &quot;lizhi&quot;;\nString b = new String(&quot;lizhi&quot;);\nString c = &quot;li&quot; + new String(&quot;zhi&quot;);\n      ![image-20250902205758484](C:\\Users\\HUAWEI\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250902205758484.png)3. intern（）方法   1. 从注释中可以比较清楚地看到，当调用intern()方法时，会判断字符串常量池中是否有该对象的引用，通过equal()方法判断，如果存在就返回字符串常量池中的对象引用。如果不存在，就把当前字符串对象直接添加到字符串常量池中，**注意这里说的把该字符串对象添加到常量池池，是指把堆中对象的引用添加到常量池，并不是在常量池中再创建一个该字符串的对象**，然后返回该对象的引用。![image-20250902205439336](C:\\Users\\HUAWEI\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250902205439336.png)# 类加载## 类加载过程### 加载1. 将类的字节码载入**方法区**，并创建.class对象。   1. JVM 找到并加载类的二进制字节流。   2. 常见来源：class 文件、JAR 包、网络、甚至动态生成（如 `ASM`、`CGLIB`）。   3. JVM 为这个类生成一个 `Class` 对象，作为方法区/元空间中该类的访问入口。   4. 如果此类的父类没有加载，先加载父类   5. 加载是懒惰执行      1. 懒惰执行：需要用到的时候才执行### 链接1. 验证：验证类是否符合class规范，做合法性、安全性检查2. 准备：为**静态变量**分配空间，设置**默认值**   &gt; *可以理解为，为了安全性必须赋初始值*3. 解析：将常量池的符号引用解析为直接引用。例如方法调用时，编译期只知道方法的符号引用（静态常量池），解析阶段才会绑定到真正的方法地址。   &gt; *这里很形象，原本只是符号引用，但是解析之后就用指针把调用链串起来了。很有“链接”的意思*### 初始化1. **执行静态代码块**与**非final静态变量的赋值**   1. 执行类构造器 `&lt;clinit&gt;()` 方法（编译器自动生成），对静态变量赋值、执行静态代码块。   2. 初始化是类加载的 最后一步，也是程序员能控制的阶段。      `&lt;clinit&gt;()` 方法由编译器收集：      - 所有 **静态变量的显式赋值**      - 所有 **静态代码块**按照源码中的顺序合并。2. 初始化时懒惰执行## 触发时机1. 只会加载 / 链接，不会初始化的情况：   1. 引用一个 `static final`       &gt; 常量会在编译期被放入调用类的常量池，也就是说，运行时根本没有去访问类，只是直接用常量池里的值。   2. 获取类的 `Class` 对象（如 `String.class`）。      &gt; JVM 只需要返回一个指向 **类元信息的引用**2. 必须初始化的情况   1. `new` 一个对象。      &gt; 在创建对象前，需要保证该类的 **静态变量、静态方法、父类状态** 都处于可用的、已知的状态。   2. 访问类的静态变量或调用静态方法（非常量）。   3. 反射调用 `Class.forName()`。   4. 初始化一个类时，若其父类还没初始化，会先初始化父类。   5. JVM 启动时，执行 `main` 方法所在的类。\n\n\n\n\n\n例子：class A {    static {        System.out.println(“A init”);    }    public static final int X &#x3D; 100;   &#x2F;&#x2F; 编译期常量    public static final int Y &#x3D; new java.util.Random().nextInt(10); &#x2F;&#x2F; 运行期常量}\npublic class Test {    public static void main(String[] args) {        System.out.println(A.X); &#x2F;&#x2F; 访问 X        System.out.println(A.Y); &#x2F;&#x2F; 访问 Y    }\n}输出结果：100A init123Q1：为什么访问 X 不会触发初始化？A1：\tX &#x3D; 100 是 编译期可确定的常量（字面量）。\tJava 编译器在编译 Test 类的时候，就把 A.X 直接替换为字面量 100，并存到 Test 的常量池 中。\t也就是说，运行时根本没有去访问 A 类，只是直接用常量池里的值。\t所以不会触发 A 的初始化。\t这就是所谓的 常量传播&#x2F;常量折叠优化。\nQ2：为什么访问 Y 会触发初始化？A2：\tY 的值依赖于 new Random().nextInt(10)，这是运行时才能确定的。\t编译器无法在编译期把它折叠进常量池。\t所以，运行时访问 A.Y 时，必须先执行类的 () 方法来初始化 Y。\t这就会触发 A 的初始化。\n## 类加载器### 分类在 JVM 中，类的加载是由类加载器完成的。常见的三层体系：1. 启动类加载器（Bootstrap ClassLoader）   - C++ 实现，JVM 自带，不是 Java 类。   - 负责加载核心类库（`rt.jar`，Java 9 之后是 `java.base` 模块），即`%JAVA_HOME%/lib`2. 扩展类加载器（Extension ClassLoader / Platform ClassLoader）   - 负责加载 `JAVA_HOME/jre/lib/ext` 或 `java.ext.dirs` 下的类库，即即`%JAVA_HOME%/lib/etc`   - Java 9 之后改为 Platform ClassLoader。3. 应用类加载器（AppClassLoader）   - 负责加载 classpath 下的类（我们写的应用代码）。另外，还可以有 自定义类加载器，一般继承 `ClassLoader`。### 特性1. 用来确定类的唯一性   1. 一个类在 JVM 内存中只能有一个唯一的定义，由**类加载器 + 类的全限定名**唯一确定。二元组&lt;N（全限定名）, L（类加载器）&gt;。   1. **一个类由哪个类加载器真正加载了，那么它的 `getClassLoader()`方法返回的就是那个类加载器。**2. 传递性   ![image-20250902154447055](C:\\Users\\HUAWEI\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250902154447055.png)   1. 如果类A是由L0加载的，那么A所依赖的类也要通过L0加载。   2. 即使是核心类库中的类，也要通过L0加载，但是会被委派到Bootstrap ClassLoader加载3. 可见性   ![image-20250902154812128](C:\\Users\\HUAWEI\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250902154812128.png)   1. 我们说类B对于类A可见，含义是：加载A的加载器L，也可以直接或委派间接加载B   1. 在 Java 中，一个类加载器只能看到它自身以及它的 父类加载器（Parent ClassLoader）所加载的类，但看不到它的 子类加载器（Child ClassLoader） 所加载的类。## 双亲委派机制### 概述1. 为什么要双亲委派？   1. 避免重复加载（保证类的唯一性）：**如果一个类已经被父加载器加载过了，子加载器就不会再加载一次，避免了同一个类被多次加载、导致类型不一致的问题。**   2. 保证核心类库的安全性（比如 `java.lang.String` 不会被随便篡改）。2. 什么时候打破？   1. 一般出现在一些 **特殊场景** 下，尤其是框架 / 容器需要加载用户自定义类、插件类，或者隔离不同模块时：      1. 自定义类加载器加载应用类/插件类         - 典型例子：**Tomcat、Jetty 等 Web 容器**         - 它们需要加载不同 Web 应用的类，避免不同应用之间互相干扰（类隔离）。         - Tomcat 会自己实现类加载器，不完全遵循双亲委派。      2. 实现热加载（Hot Deployment）         - 开发工具（如 IDEA、Eclipse）、Spring Boot DevTools 热部署功能，需要在运行时重新加载类。         - 如果走双亲委派，父加载器一旦加载过，就无法替换，需要自己写类加载器打破机制。      3. SPI（Service Provider Interface）机制：**顶层加载器需要调用应用类加载器**。顶层提供接口，底层实现         - Java 自带的 `ServiceLoader` 需要加载厂商提供的实现类（通常在 `META-INF/services` 里）。         - 这些实现类不能放在 JDK 的核心类加载器里，只能由 **线程上下文类加载器（Thread Context ClassLoader）** 去加载，突破双亲委派。      4. 模块/插件化系统         - 比如 OSGi、各种插件化框架，需要动态加载第三方 jar 包，并且允许卸载/升级插件。         - 通常需要定制自己的类加载逻辑，不完全依赖父加载器。      5. 字节码增强 / 动态代理         - 一些框架（Spring、MyBatis、JVM Agent、字节码增强工具 ASM/CGLIB）在运行时生成代理类。         - 这些类需要在运行时被加载进 JVM，往往会使用自定义类加载器绕过双亲委派。### 机制内容![image-20250902153715595](C:\\Users\\HUAWEI\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250902153715595.png)![image-20250902153959633](C:\\Users\\HUAWEI\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250902153959633.png)1. 工作过程   1. 当应用类加载器要加载一个类时，比如 `java.lang.String`。   2. 它不会自己去尝试加载，而是先 **委托给父加载器（Platform ClassLoader）**。   3. Platform ClassLoader 又委托给 Bootstrap ClassLoader   4. Bootstrap ClassLoader 如果能加载（发现 String 在核心库里），就直接返回。   5. 如果父加载器都没找到，才由子加载器自己去加载。2. 作用核心目的就是 **安全性和一致性**：   1. **保证核心类库不会被篡改**      1. 假设你写了一个自定义的 `java.lang.String` 类，如果没有双亲委派，你的 `String` 可能会被应用类加载器加载并替代系统的核心类，这是极其危险的。      2. 但因为双亲委派，加载 `java.lang.String` 的请求会交给 Bootstrap ClassLoader，它会优先加载 JDK 自带的版本，从而保证安全。   2. **保证类的唯一性**      1. 一个类在 JVM 内存中只能有一个唯一的定义（由 **类加载器 + 类的全限定名** 唯一确定）。      2. 如果一个类已经被父加载器加载过了，子加载器就不会再加载一次，避免了同一个类被多次加载、导致类型不一致的问题。### 依赖冲突- 有一个典型的题目：有一个项目P，依赖于包B、C，这两个包又分别依赖A1.0、A2.0，且如果B用A2.0或者C用A1.0都会出错。此时如何让项目正常运行。  1. 一个类在JVM中的定义是由**&lt;类加载器+全限定名&gt;**决定的，如果在项目中用同一个类加载器加载了同一个路径下的A，就会导致冲突  2. 核心思路是让B、C分别依赖不同版本的包A，所以就要让他们依赖的A的类加载器或全限定名不一样。- 由此提出以下解决方案：  - 重构包名  - 打破双亲委派模型，使用自定义类加载器来实现类隔离  - 在Maven中显式指定依赖  - 使用兼容包### 打破双亲委派1. 重写ClassLoader中的loadClass方法2. 使用线程上下文加载器3. 为什么要打破双清委派？   1. **类隔离需求**：不同的框架、应用或模块可能需要加载 **同名但不同版本的类**，例如两个 Web 应用都用了不同版本的同一个库（如 Log4j）。如果都遵循双亲委派，所有类都由同一个类加载器加载，就会导致版本冲突。   2. **热部署 / 热加载**：在服务器环境中，我们可能希望在不重启整个 JVM 的情况下重新加载某个应用或模块，这就要求该模块的类能被独立加载和卸载，而双亲委派模型不利于这种灵活的类生命周期管理。   3. **框架/容器需要加载用户代码**：比如在 Web 容器中，容器本身和用户部署的 Web 应用可能都会用到一些公共的类（如 Servlet 相关类），但容器希望 **对这些类有统一的控制权**，同时又能让每个 Web 应用自己的类库相互隔离，避免互相干扰。## 数组类1. 所有数组实例都属于Object，每个数组实例都有自己的class2. 数组类本身不通过类加载器创建，而是通过JVM直接创建3. 数组类的元素需要类加载器创建4. 数组类也需要通过&lt;N, L&gt;唯一确定# 运行## 垃圾回收![image-20250902111808844](C:\\Users\\HUAWEI\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250902111808844.png)1. GC（Garbage Collection）发生在堆区2. 过程：   1. new对象出生在E区。当E区快满了，触发youngGC。扫描young区所有类，如果某个对象没有引用了，就打个标记，最后删除。幸存的对象复制到S区   2. S0和S1交替使用   3. 每幸存一轮，对象age加一   4. 如果某个对象达到一定年龄（可以是6岁），则转移到O区。   5. O区存放**老年对象**或**大对象**。   6. 如果O区快满了，则触发oldGC，暂停程序，全力垃圾回收。3. E区比S0区为8:14. 老年代比年轻代为2:1### 标记算法1. 引用计数算法：给每个对象记录一个引用计数属性，该属性为0则表示是垃圾。但是无法解决循环引用问题。2. 可达性算法：在内存中从根对象一直向下找引用，找不到的就是垃圾对象。   1. GC Roots 是一组特殊的引用起点，垃圾回收器从这些起点出发，遍历引用链，标记所有可达的对象。   2. 有多个根对象，但是只会选用一个。      1. 栈中引用的对象      2. 常量引用的对象      3. 类静态属性引用的对象      4. Native方法引用的对象### 回收算法1. **标记清除算法**   1. 基本思想      1. 标记阶段（Mark）：从 GC Roots 出发，遍历所有可达对象，将这些对象 标记为存活。      2. 清除阶段（Sweep）：遍历整个堆，把 未被标记的对象（即垃圾）清理掉。   2. 优点      1. 不需要移动对象，实现相对简单   3. 缺点      1. 内存碎片化严重      2. 效率问题2. **复制算法**   1. 基本思想      1. 将 堆内存分为两块（通常称为 From 区和 To 区，或者 S0 和 S1）      2. 每次只使用其中一块（如 From 区）来分配对象      3. 当这一块内存满了，就触发 GC：将存活的对象复制到另一块空闲内存区域（To 区）然后 一次性清空当前使用的内存块（From 区）      4. 交换角色：原来的 To 区成为新的 From 区，继续使用   2. 优点      1. 没有内存碎片！      2. 分配效率高      3. 适合对象存活率低的场景   3. 缺点      1. 浪费了一半的内存空间      2. 不适合存活对象多的场景3. **标记压缩算法**   1. 基本思想      1. 标记阶段（Mark）：同 Mark-Sweep，从 GC Roots 出发，标记所有存活对象      2. 压缩阶段（Compact）：将所有 存活对象向堆的一端移动（通常是向左或向右紧凑排列）      3. 清理边界外内存：移动完成后，直接清理掉剩余的未使用内存空间   2. 优点      1. 没有内存碎片！（解决了 Mark-Sweep 的最大问题）      2. 内存利用率高，适合大对象和长期存活对象分配   3. 缺点      1. 移动对象成本高！### 垃圾回收器不是所有垃圾回收的阶段都会触发 STW，但 **很多关键阶段必须 STW**，以下是一些常见 GC 算法的 STW 情况：1. **Serial GC / Serial Old GC（单线程 GC）**- **特点：** 单线程，适合客户端应用或小内存环境- STW：标记阶段（标记存活对象）清除/整理阶段都是 STW 的！整个过程都会暂停所有应用线程&gt; ✅ 用户线程完全停止，卡顿感明显，不适合高并发服务端应用2. **Parallel GC（多线程版本的 Serial，也叫吞吐量优先 GC）**- **特点：** 多线程并行执行 GC，适合后台计算型任务- STW：标记、清除、压缩等阶段大多是 STW 的同样会暂停所有应用线程&gt; ✅ 吞吐量高，但停顿时间仍然较长3. **CMS（Concurrent Mark-Sweep，老年代 GC，并发标记清除）**- **特点：** 目的是 **减少 STW 时间**，适合对延迟敏感的应用- **STW 阶段：**  - 初始标记（Initial Mark）**：**STW，只标记 GC Roots **直接**关联的对象（很快）  - 并发标记（Concurrent Mark）**：**与应用线程并发执行，不 STW。存在错标、漏标。  - 重新标记（Remark）**：**STW**，修正并发标记期间用户线程修改的引用关系（关键！）**  - 并发清除（Concurrent Sweep）**：**不 STW&gt; ✅ **CMS 通过并发标记减少了 STW 时间，但仍有 2 次较短的 STW（初始标记和重新标记）**4. **G1 GC（Garbage First，JDK 9+ 默认 GC）**- **特点：** 面向服务端，将堆划分为多个 Region，目标是控制停顿时间- STW 阶段：  - 初始标记（Initial Mark）**：**STW并发标记  - 最终标记（Remark）**：**STW  - 筛选回收（Cleanup / Evacuation）：部分阶段 STW&gt; ✅ G1 通过分 Region 和并发/并行结合，进一步优化了 STW 时间，是 JDK 9 后的默认 GC- | 设计点                                                       | 说明                                                         |  | :----------------------------------------------------------- | :----------------------------------------------------------- |  | **1. 堆的逻辑结构改变：不再分“年轻代”“老年代”物理隔离**      | 而是将整个 Java 堆划分为多个大小相等的 **Region（区域）**，每个 Region 可以是 Eden、Survivor 或 Old 区，**动态分配角色** |  | **2. 可预测的停顿时间模型（Pause Prediction Model）**        | 你可以设置一个目标停顿时间（比如 200ms），G1 会尽量在每次 GC 时控制在这个范围内 |  | **3. 分 Region 回收，优先回收垃圾最多的 Region（Garbage First）** | G1 会优先选择 **垃圾比例最高（存活对象最少）的 Region** 进行回收，从而提高回收效率，这就是名字中 **“Garbage First”** 的来源 |  | **4. 并发与并行结合**                                        | - 并发标记（和应用线程一起运行） - 并行回收（STW，多线程加速） |5. **ZGC（Z Garbage Collector，JDK 11+ 实验性，JDK 17+ 生产可用） &amp; Shenandoah**- **特点：** **超低延迟 GC，目标 STW 时间不超过 10ms，甚至 1ms**- STW：极短，大部分阶段都是并发执行的只会在极少数关键阶段有非常短暂的 STW&gt; ✅ ZGC 是目前最先进的低延迟 GC，适合超大堆、超低延迟场景（如金融、游戏、实时系统）# 编程## JVM详解## 内存区![image-20250902110508883](C:\\Users\\HUAWEI\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250902110508883.png)### 堆1. 是 JVM 中 最大的一块内存区域，用于存放**所有**对象实例和数组（即通过 `new`创建的对象）。2. 是 垃圾回收器（Garbage Collector, GC）主要管理的区域。### 栈（虚拟机栈）1. 每个线程运行时都会创建一个 **虚拟机栈**，用于存储 **栈帧（Stack Frame）**，每个栈帧对应一个方法调用。2. 栈帧中包含：   1. 局部变量表（Local Variables）：存储方法参数和局部变量   2. 操作数栈（Operand Stack）：用于计算   3. 动态链接（Dynamic Linking）   4. 方法返回地址（Return Address）### 方法区1. 作用：   - 用于存储 已被虚拟机加载的**类信息、常量、静态变量**、即时编译器编译后的代码等数据。   - 是 Java 类的“元数据”存储区域。2. 特点：   - 线程共享   - 存放内容：类的结构信息（如类名、方法、字段、父类、接口等）**静态变量（static 变量）常量池（运行时常量池）**JIT 编译后的代码   - 在 HotSpot 虚拟机中，方法区的实现叫 “永久代（PermGen，Java 7 及之前）” 或 “元空间（Metaspace，Java 8 及之后）”   &gt; ⚠️ 注意：方法区是 JVM 规范中定义的逻辑区域，而永久代 / 元空间 是 HotSpot 的具体实现。3. **运行时常量池（Runtime Constant Pool）【线程共享，属于方法区的一部分】**   - 是方法区的一部分，用于存放 **编译期间生成的各种字面量和符号引用**，如：字符串常量（如 `&quot;Hello&quot;`）final 常量类/方法/字段的符号引用### 本地方法栈1. 作用   - 为 JVM 调用的 **Native 方法（如 C/C++ 写的方法，通过 JNI 调用）** 服务   - 类似于 Java 虚拟机栈，但是服务于本地（非 Java）方法### 程序计数器1. 作用：   - 是一块较小的内存空间，是 **当前线程执行的字节码的行号指示器**   - 用于记录当前线程正在执行的字节码指令地址，线程切换时能恢复执行位置2. 特点：   - **线程私有**   - **唯一一个在 JVM 规范中没有任何 OutOfMemoryError 情况的区域**   - 如果线程执行的是 Java 方法，计数器记录的是正在执行的字节码指令地址；   - 如果执行的是 Native 方法，则计数器值为空（Undefined）## 数据结构### List#### ArrayList1. 概述   1. 是一种集合，底层基于 **可扩容数组**。   2. 底层通过数组实现，初始大小为10；   3. 扩容以1.5倍放大2. 用法   1.    2. | 分类      | 方法                    | 说明                 |      | --------- | ----------------------- | -------------------- |      | 增加      | `add(E e)`              | 在末尾添加           |      |           | `add(int index, E e)`   | 在指定位置插入       |      | 删除      | `remove(int index)`     | 删除指定下标的元素   |      |           | `remove(Object o)`      | 删除匹配的第一个元素 |      |           | `clear()`               | 清空列表             |      | 修改/获取 | `get(int index)`        | 获取指定下标元素     |      |           | `set(int index, E e)`   | 修改指定下标元素     |      |           | `size()`                | 返回大小             |      |           | `isEmpty()`             | 是否为空             |      | 查找      | `contains(Object o)`    | 是否包含元素         |      |           | `indexOf(Object o)`     | 返回第一个匹配下标   |      |           | `lastIndexOf(Object o)` | 返回最后一个匹配下标 |#### LinkeList1. 概述2. 用法   1.    2. | 分类 | 方法                         | 说明                          |      | ---- | ---------------------------- | ----------------------------- |      | 增加 | `add(E e)`                   | 在末尾添加                    |      |      | `addFirst(E e)`              | 在头部添加                    |      |      | `addLast(E e)`               | 在尾部添加                    |      |      | `push(E e)`                  | 入栈（= addFirst）            |      | 删除 | `remove()` / `removeFirst()` | 删除并返回头部元素            |      |      | `removeLast()`               | 删除并返回尾部元素            |      |      | `remove(Object o)`           | 删除指定对象                  |      |      | `pop()`                      | 出栈（= removeFirst）         |      |      | `clear()`                    | 清空                          |      | 获取 | `get(int index)`             | 获取指定下标元素              |      |      | `getFirst()`                 | 获取头部元素（不删除）        |      |      | `getLast()`                  | 获取尾部元素（不删除）        |      |      | `peek()` / `peekFirst()`     | 查看头部元素，空时返回 `null` |      |      | `peekLast()`                 | 查看尾部元素，空时返回 `null` |      | 其他 | `size()`                     | 返回大小                      |      |      | `isEmpty()`                  | 是否为空                      |### CopyOnWriteArrayList1. CopyOnWriteArrayList 的核心原理 —— **写时复制（Copy-On-Write）**   什么是写时复制？   1. “写时复制” 的意思就是：当你要修改这个 List（比如 add / remove / set）时，不直接在原数组上修改，而是先复制一份新的数组，在新数组上进行修改，改完后再让内部的数组引用指向这个新数组。   2. 而对于读操作（如 get、iterator），始终是从原数组（可能是旧数组）上读取，不需要加锁，也不关心是否有写操作正在进行。2. `CopyOnWriteArrayList`是一个线程安全的 List，采用 “写时复制（Copy-On-Write）” 机制实现并发安全，适合读多写少的并发场景。### Map#### HashMap1. 概述   1. 底层是数组实现，大小必须是2的幂次   2. 哈希冲突会在对应位置生成链表（桶）   3. JDK8之后，链表达到一定长度后会变成红黑树2. 用法   1.    2. | 分类      | 方法                                       | 说明                         |      | --------- | ------------------------------------------ | ---------------------------- |      | 增加/修改 | `put(K key, V value)`                      | 插入键值对（若键存在则替换） |      |           | `putAll(Map m)`                            | 批量插入                     |      |           | `putIfAbsent(K key, V value)`              | 键不存在时才插入             |      | 删除      | `remove(Object key)`                       | 删除键并返回对应的值         |      |           | `remove(Object key, Object value)`         | 键和值都匹配时才删除         |      |           | `clear()`                                  | 清空                         |      | 获取      | `get(Object key)`                          | 获取值，不存在返回 `null`    |      |           | `getOrDefault(Object key, V defaultValue)` | 不存在时返回默认值           |      |           | `containsKey(Object key)`                  | 是否包含某个键               |      |           | `containsValue(Object value)`              | 是否包含某个值               |      | 遍历      | `keySet()`                                 | 返回所有键                   |      |           | `values()`                                 | 返回所有值                   |      |           | `entrySet()`                               | 返回键值对集合               |      | 其他      | `size()`                                   | 返回大小                     |      |           | `isEmpty()`                                | 是否为空                     |      |           | `replace(K key, V value)`                  | 替换指定键的值               |      |           | `replace(K key, V oldValue, V newValue)`   | 旧值匹配时才替换             |#### LinkedHashMap1. 底层实现几乎和HashMap一样2. 在每个元素中添加了一个链表，指向下一个插入的数据#### TreeMap1. 底层用红黑树实现2. 特点是按照Key进行排序#### HashTable1. 是线程安全的（并发安全）2. 进行写操作时会对整个HashTable上锁#### ConcurrentHashTable1. 和HashTable的区别就是只对桶上锁### Set1. 本身是通过Map实现的2. 把Value设置为null，只用Key| 方法签名                     | 说明                                                         | 示例                                        || :--------------------------- | :----------------------------------------------------------- | :------------------------------------------ || `boolean add(E e)`           | 添加元素到集合，如果集合中 **已存在该元素则不会重复添加，并返回 false** | `set.add(&quot;apple&quot;)`                          || `boolean remove(Object o)`   | 移除指定元素，成功返回 true，否则返回 false                  | `set.remove(&quot;banana&quot;)`                      || `boolean contains(Object o)` | 判断集合中是否包含某个元素                                   | `set.contains(&quot;apple&quot;)`→ true/false         || `int size()`                 | 返回集合中元素的个数                                         | `set.size()`                                || `boolean isEmpty()`          | 判断集合是否为空                                             | `set.isEmpty()`                             || `void clear()`               | 清空集合中的所有元素                                         | `set.clear()`                               || `Iterator&lt;E&gt; iterator()`     | 返回集合中元素的迭代器，用于遍历                             | `for (String s : set) &#123; ... &#125;`              || `Object[] toArray()`         | 将集合转换为 Object 数组                                     | `Object[] arr = set.toArray()`              || `&lt;T&gt; T[] toArray(T[] a)`     | 将集合转换为指定类型的数组                                   | `String[] arr = set.toArray(new String[0])` |### Queue| 分类         | 方法                 | 功能                   | 队列为空/满时的表现                     || ------------ | -------------------- | ---------------------- | --------------------------------------- || **插入**     | `add(E e)`           | 插入一个元素           | 队列满时抛异常 `IllegalStateException`  ||              | `offer(E e)`         | 插入一个元素           | 队列满时返回 `false`                    || **查看队头** | `element()`          | 获取队头元素，但不删除 | 队列空时抛异常 `NoSuchElementException` ||              | `peek()`             | 获取队头元素，但不删除 | 队列空时返回 `null`                     || **移除队头** | `remove()`           | 删除并返回队头元素     | 队列空时抛异常 `NoSuchElementException` ||              | `poll()`             | 删除并返回队头元素     | 队列空时返回 `null`                     || **其他**     | `size()`             | 返回队列元素个数       | 0（如果队列空）                         ||              | `isEmpty()`          | 判断队列是否为空       | true/false                              ||              | `clear()`            | 清空队列               | 队列变空                                ||              | `contains(Object o)` | 判断是否包含某元素     | true/false                              |#### PriorityQueue1. 概述   1. `PriorityQueue&lt;E&gt;` 是 Java 提供的 **基于堆 (Heap)** 的优先队列实现类。      1. 插入元素：`O(log n)`      2. 删除堆顶：`O(log n)`      3. 获取堆顶：`O(1)`      4. 遍历 `PriorityQueue` 得到的结果 **不是排序好的**      5. **允许重复元素**，不允许 `null`。   2. 默认大小是11.      1. 当元素个数超过当前容量时，会 **自动扩容**。         扩容规则：         1. 如果旧容量 &lt; 64 → 新容量 = `(旧容量 * 2) + 2`            （比如 11 → 24 → 50 …）         2. 如果旧容量 ≥ 64 → 新容量 = `旧容量 + (旧容量 &gt;&gt; 1)`            （相当于 1.5 倍扩容，比如 64 → 96 → 144 …）   3. 默认是 **最小堆**：堆顶元素是“最小值”。   4. 如果要最大堆，需要自定义 **比较器 (Comparator)**。   5. 常见应用：**Top K 问题、任务调度、最短路径算法 (Dijkstra)、Huffman 编码** 等。2. 用法   1. 构造方法      1. ```java         PriorityQueue&lt;Integer&gt; pq1 = new PriorityQueue&lt;&gt;();           // 默认最小堆                  PriorityQueue&lt;Integer&gt; pq2 = new PriorityQueue&lt;&gt;(Collections.reverseOrder());           // 最大堆                  PriorityQueue&lt;String&gt; pq3 = new PriorityQueue&lt;&gt;(Comparator.comparingInt(String::length));           // 自定义比较规则：字符串长度         \n\n\n调用方法参考普通队列\n\n双端队列\n构造：Deque&lt;Integer&gt; deque = new LinkedList&lt;Integer&gt;();。从中可以看出，其本质就是一个链表。只不过为了面向接口编程，这样定义不会误用其他方法。\n用法：\nofferFirst、offerLast等等\n\n\n\n红黑树\n也是对树结构的平衡，但是和AVL树有区别\nAVL 树（严格平衡，查找快）\n红黑树（相对平衡，插入&#x2F;删除更快，综合性能更好）\n\n\n\n\n五大原则\n每个节点要么是红色，要么是黑色。​​\n根节点必须是黑色。\n叶子节点（NIL &#x2F; 空节点）视为黑色。\n红色节点的两个子节点都必须是黑色（即不能有两个连续的红色节点）。\n从任意一个节点到其所有后代叶子节点的路径上，黑色节点的数量相同（称为黑高相同）。\n\n\n\n\n口诀：左根右（二叉搜索树），根叶黑，不红红，黑路同\n\n\n插入\n\n默认插入点（cur）节点是红色的\n破坏了根叶黑：若插入节点是根节点，直接变黑\n破坏了不红红：\n若插入节点的“叔叔”节点（父节点的兄弟节点）是红色，则叔父爷变色，cur指向爷爷，然后递归判定原则\n若插入节点的叔叔节点是黑色，则进行旋转（同AVL树），然后旋转中心点和旋转点变色\n\n\n\n\n删除：\n\n\n理念：\n对于一般的二叉搜索树，删除都有三种情况：叶节点，有一个子树，有两个子树。但是有两个子树的情况最终是转换成前两种情况。所以针对红黑树，我们只需要研究前两种就好了\n针对红黑树，只有一个子树时，子树一定只有一个节点。否则要么违反不红红，要么违反黑路同\n\n\n删除叶节点：\n红色：直接删除\n黑色：我们把要调整的节点成为“双黑节点”，代表经过它的路径都少一个黑节点\n兄弟节点是黑色：\n兄弟节点至少有一个红色孩子：\n变色：兄弟节点、其红孩子和父节点都要集成对应的上级节点的颜色\n旋转\n\n\n兄弟节点只有黑孩子：\n把兄弟节点变为红色，那么就恢复了局部的黑路同，双黑节点交给父节点\n递归处理\n\n\n\n\n兄弟是红节点：兄父变色，朝双黑旋转\n\n\n\n\n\n\n\nB+树\n和B树的区别\n\n很像。当我们要遍历树中元素时，对于B树，需要中序遍历，这要求指针来回跳跃，非常耗时。\n\n而B+数则要求在叶节点上保存所有的元素，并且从小到大链接起来\n\n对于非叶子结点，每个元素代表对应子节点的最大值。\n\n非叶子节点相当于只是索引\n\n\n\n\n异常处理异常体系\n所有异常都来自于顶级父类Throwable\nThrowable下有两个子类：Exception, Error\nError：表示非常严重的错误（JVM或系统级），程序无法解决。\n比如，OutOfMemoryError（内存不足，堆内存溢出），StackOverflowError，（栈溢出，比如无限递归）\n\n\nException：表示程序可以解决的异常。Exception一般又可以分为RuntimeException和Checked Exception（受检异常 &#x2F; 必检异常）。\nRuntimeException：运行时异常，一般为逻辑错误。\nChecked Exception：检查异常，由编译器要求必须处理\n\n\n\n\n\n异常处理\ntry-catch-finally\n用于 捕获并处理异常：\ntry &#123;    // 可能抛出异常的代码&#125; catch (IOException e) &#123;    // 捕获并处理 IOException    e.printStackTrace();&#125; catch (Exception e) &#123;    // 捕获其他异常&#125; finally &#123;    // 无论是否异常都会执行的代码（如关闭资源）&#125;\n\n\n\nthrows（声明抛出）\n\n如果当前方法 不想处理某个受检异常，可以将其抛给调用者处理：\npublic void readFile() throws IOException &#123;    // 可能抛出 IOException 的代码&#125;\n\n调用者必须继续处理这个异常（catch 或继续 throws）。\n\n\n自定义异常\n你可以根据业务需求定义自己的异常类，通常继承自：\n\nException（受检异常）\nRuntimeException（运行时异常）\n\n示例：自定义受检异常\npublic class MyCheckedException extends Exception &#123;    public MyCheckedException(String message) &#123;        super(message);    &#125;&#125;\n\n示例：自定义运行时异常\npublic class MyUncheckedException extends RuntimeException &#123;    public MyUncheckedException(String message) &#123;        super(message);    &#125;&#125;\n\n泛型和多态\n泛型的实现\n\n泛型（Generics）是如何实现的？ → 核心机制：类型擦除（Type Erasure）\n\n✅ 1. 泛型的本质：编译期的类型检查，运行时类型擦除\n\nJava 的泛型是通过 “类型擦除（Type Erasure）” 实现的，这意味着泛型信息只在编译阶段存在，用于类型检查，而在编译成字节码后，类型参数会被擦除，替换为默认类型（通常是 Object 或指定的边界类型）。\n\n\n✅ 2. 举个例子 👇\n你写这样的泛型代码：List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;Hello&quot;);String s = list.get(0); // 不需要强转\n\n但在编译后（字节码层面），它实际上变成了：List list = new ArrayList(); // 类型参数 &lt;String&gt; 被擦除了list.add(&quot;Hello&quot;);String s = (String) list.get(0); // 编译器自动插入了强制类型转换\n\n\n✅ 编译器在编译时保证了你只能放入 String，取出时也自动帮你转回 String，但运行时 JVM 看到的只是原始类型 List。\n\n\n✅ 3. 类型擦除的规则\n\n\n\n情况\n擦除后变成什么\n\n\n\nList&lt;T&gt;\n擦除为 List&lt;Object&gt;（JDK 1.5 早期）或更准确地说是 List（原始类型）\n\n\nList&lt;String&gt;\n擦除为 List，但编译器会做类型检查并插入强制转换\n\n\nT extends Number（比如 List&lt;Integer&gt;）\n擦除为 Number，即上限类型\n\n\nT没有指定边界\n擦除为 Object\n\n\n\n✅ 4. 为什么用类型擦除实现泛型？\n\n历史原因：为了兼容 Java 5 之前的代码（非泛型代码），保证泛型引入后 旧代码依然能运行，不破坏二进制兼容性。\nJVM 层面没有泛型支持：Java 的虚拟机（JVM）本身并不直接认识泛型类型，它是基于原始类型运作的。\n\n\n✅ 总结：泛型是 Java 编译器层面的语法糖，它通过类型擦除在编译时提供类型安全，运行时则“擦除”掉具体类型信息。\n\n\n\n\n\n线程创建\n\n\n方式\n说明\n是否推荐\n适用场景\n\n\n\n1️⃣ 继承 Thread类\n自定义类继承 Thread，重写 run()方法\n⭐ 不推荐\n简单示例、学习线程基础\n\n\n2️⃣ 实现 Runnable接口\n实现 Runnable接口，实现 run()方法，传给 Thread 对象\n⭐⭐⭐⭐ 推荐\n大多数场景，灵活、面向接口\n\n\n3️⃣ 实现 Callable&lt;V&gt;接口 + FutureTask\n类似 Runnable，但可以有返回值，能抛异常\n⭐⭐⭐ 推荐（需要返回值时）\n需要获取线程执行结果的场景\n\n\n4️⃣ 使用线程池（Executor 框架）\n通过线程池（如 Executors）管理线程的创建和执行\n⭐⭐⭐⭐⭐ 强烈推荐\n生产环境、高并发、线程复用\n\n\n\n创建线程池参数\n\npublic ThreadPoolExecutor(\n    int corePoolSize,                  // 核心线程数\n    int maximumPoolSize,               // 最大线程数\n    long keepAliveTime,                // 空闲线程存活时间\n    TimeUnit unit,                     // 时间单位\n    BlockingQueue&lt;Runnable&gt; workQueue, // 任务队列\n    ThreadFactory threadFactory,       // 线程工厂\n    RejectedExecutionHandler handler   // 拒绝策略\n)\n\n### 线程池1. 工作原理   1. 步骤 1：如果当前线程数 &lt; 核心线程数（corePoolSize）      - 线程池会 立即创建一个新线程 来执行这个任务      - 该线程执行完任务后 不会被销毁，而是进入线程池中 等待下一个任务   2. 步骤 2：如果线程数 ≥ 核心线程数，但任务队列未满      - 线程池 不会创建新线程      - 而是把任务放入 任务队列（workQueue）中等待      - 空闲的核心线程会 从队列中取出任务执行   3. 步骤 3：如果任务队列已满，但线程数 &lt; 最大线程数（maximumPoolSize）      - 线程池会 创建新的线程（非核心线程） 来执行这个任务      - 这些线程在完成任务后，如果 空闲时间超过 keepAliveTime，就会被销毁   4. 步骤 4：如果线程数已达最大线程数，且任务队列已满      - 线程池会触发 拒绝策略（RejectedExecutionHandler）比如抛出异常、丢弃任务、由调用线程自己执行等2. 注意，是等待队列满了之后才会创建新线程。### ThreadLocal1. 是什么？   1. `ThreadLocal`是 Java 中一个非常有特色的线程绑定机制，它提供了一种**线程本地存储**（Thread-local Storage）的方式，即 每个线程都有自己独立的变量副本，线程之间互不干扰，从而避免了多线程环境下的共享变量同步问题。   2. **ThreadLocal 本身是用来存储单个线程的单一变量（一个 ThreadLocal 对应一个值）**2. 应用场景   1. 线程上下文信息传递（如用户登录信息、请求上下文）      在 Web 应用或服务端程序中，一个请求往往由一个线程处理，我们经常需要在处理过程中传递一些上下文信息，比如：      - 当前登录用户信息（User）      - 请求 ID（traceId / requestId）      - 数据源信息      - 事务上下文      如果通过方法参数一层层传递，代码会非常冗余。使用 `ThreadLocal`可以优雅地解决这个问题，让这些信息**在当前线程中“全局可见”**   2. 数据库连接、Session 等线程隔离资源管理      1. 为了保证每个线程使用独立的数据库连接，避免多线程并发问题，会使用 `ThreadLocal`来保存当前线程的 Connection 或 Session。3. 底层原理   1. 每个 Thread 对象内部都有一个 ThreadLocalMap   2. 数据结构：ThreadLocalMap（类似简易的 HashMap）      - `ThreadLocalMap`是 ThreadLocal 的静态内部类      - 它的 **key 是 ThreadLocal 对象本身（弱引用）**      - value 是线程本地存储的实际值      - 它是一个 定制化的哈希表，专门为 ThreadLocal 服务   3. ```java      Thread      └── threadLocals: ThreadLocalMap             ├── key: ThreadLocal 对象1（弱引用） → value: 线程1的变量值1             ├── key: ThreadLocal 对象2（弱引用） → value: 线程1的变量值2             └── ...                   （每个线程都有自己的 threadLocals，彼此独立）\n\n\n\n\n内存泄露问题\n\nEntry 的 key 是 ThreadLocal 对象的弱引用，但 value 是强引用\n当你不再引用这个ThreadLocal，但是线程长期存活时，当遇到GC，key就会被回收（因为是弱引用），但是value没法回收。造成泄露。\n一定要用threadLocal.remove()手动回收\n\n\n\n同步乐观锁和悲观锁\n\n\n对比维度\n悲观锁（Pessimistic Locking）\n乐观锁（Optimistic Locking）\n\n\n\n核心思想\n“总会有人抢，先加锁，防止冲突”\n“大家不一定会冲突，先尝试，冲突了再处理”\n\n\n锁的获取\n操作数据前先加锁，阻止其他人修改\n操作数据前不加锁，提交时检查是否被修改过\n\n\n并发性能\n并发度低，线程会阻塞，上下文切换开销大\n并发度高，无阻塞，靠重试或版本控制解决冲突\n\n\n适用场景\n冲突频繁，写多读少（如银行转账）\n冲突较少，读多写少（如计数器、浏览量）\n\n\n实现方式\nsynchronized、ReentrantLock、数据库行锁&#x2F;表锁等\nCAS、版本号（version）、时间戳等\n\n\n典型实现\nsynchronized、Lock 接口、数据库的 SELECT ... FOR UPDATE\nCAS（Compare-And-Swap）、version字段、AtomicXXX\n\n\n是否阻塞\n是（线程会等待锁）\n否（线程不会阻塞，冲突时重试或失败）\n\n\nAQS\n\n\n项目\n说明\n\n\n\nAQS 是什么\nJava 并发包中实现锁和同步器的底层核心框架（如 ReentrantLock、Semaphore 的基础）\n\n\n核心功能\n管理同步状态（state）、线程排队（CLH 队列）、阻塞与唤醒\n\n\n核心变量\nvolatile int state：表示同步状态（比如锁是否被占用、剩余许可数等）\n\n\n核心机制\n线程获取资源失败时进入队列等待，资源可用时被唤醒\n\n\n两种模式\n独占模式（如锁）、共享模式（如信号量、读锁）\n\n\n子类实现\n开发者通过重写 tryAcquire&#x2F; tryRelease等方法，定义资源获取与释放逻辑\n\n\n应用广泛\n是 Java 中大部分同步工具（如 Lock、Semaphore、CountDownLatch）的底层实现基础\n\n\n\nAQS（AbstractQueuedSynchronizer，抽象队列同步器） 是 Java 并发包（java.util.concurrent）中 最核心、最基础的同步框架，它是 构建锁和同步器（如 ReentrantLock、Semaphore、CountDownLatch、ReentrantReadWriteLock 等）的基石。\n\n作用\n\n同步状态的管理（比如锁是否被占用、资源数是否足够）\n线程的排队与阻塞（当资源不可用时，线程进入等待队列）\n线程的唤醒与通知（当资源可用时，唤醒等待线程）\n\n它主要用于构建 锁（Lock）和同步器（Synchronizer），是 实现线程安全与并发控制的重要基础框架。\n\n工作原理\n\n同步状态（State）\nAQS 内部维护了一个 volatile int 类型的 state 变量，表示 同步状态，这个状态的意义取决于具体的同步器实现\n\n线程的排队（CLH 队列）\n当某个线程尝试获取资源（比如锁、许可）但 失败时（比如锁被占用、许可不足），AQS 会将该线程封装成一个 Node 节点，并加入到一个 FIFO（先进先出）的等待队列中，这个队列叫做 CLH 队列（Craig, Landin, and Hagersten 队列）。\n\n阻塞与唤醒\n\n当线程获取资源失败时，AQS 会通过 LockSupport.park() 将线程阻塞（挂起）\n当资源可用时（比如其他线程释放了锁或许可），AQS 会通过 LockSupport.unpark() 唤醒队列中的线程\n\n\n\n\nAQS 底层数据结构 —— CLH 队列（简化理解）\n\n当线程获取资源失败时，AQS 会将线程封装成 Node 节点，并加入到一个 FIFO 队列（CLH 队列） 中等待。\n每个 Node 代表一个等待的线程\n队列是 双向链表结构\n头节点一般是占用资源的线程，后续节点是排队等待的线程\n\n\n\n\n\nsynchronized\n在 Java 中，当多个线程同时访问共享资源（比如一个变量、对象、集合等）时，如果没有合理的同步措施，就可能导致数据不一致、线程安全问题。\n\n\n同步关键字 synchonized\n\nsynchronized是 Java 提供的最基本的线程同步机制，它基于 对象监视器（monitor），可以修饰 方法 或 代码块，保证同一时刻 只有一个线程能进入被 synchronized 保护的代码区域。\n\n使用方法（只展示如何锁住代码块）：\n\npublic class Counter {\n    private int count = 0;\n    private final Object lock = new Object(); // 任意对象，作为锁对象\n\n    public void increment() {\n        synchronized (lock) {  // 只锁定需要同步的代码块，不是整个方法\n            count++;\n        }\n    }\n}\n2. 锁升级：   1. 根据线程竞争的情况，synchronized 锁会从 偏向锁 → 轻量级锁 → 重量级锁 逐步升级，尽量以最小的性能代价实现线程同步。   2. 三层锁状态      1.       2. | 锁状态                              | 说明                                                         | 适用场景                                        | 底层实现                                                  |         | :---------------------------------- | :----------------------------------------------------------- | :---------------------------------------------- | :-------------------------------------------------------- |         | **1. 偏向锁（Biased Lock）**        | 假设锁只会被 **一个线程访问**，不存在竞争，**加锁时几乎没有额外开销** | 单线程访问同步代码块的场景                      | 通过对象头 Mark Word 中记录偏向线程ID                     |         | **2. 轻量级锁（Lightweight Lock）** | 假设锁 **只有少量线程交替访问，竞争不激烈**，采用 **CAS 自旋方式获取锁，线程不阻塞** | 多线程交替执行，但 **没有或很少真正的并发争抢** | 通过 CAS 操作和栈帧中的 **Lock Record** 实现              |         | **3. 重量级锁（Heavyweight Lock）** | 当多个线程 **真正并发竞争锁时**，轻量级锁升级为重量级锁，线程会进入 **阻塞状态，由操作系统管理** | 高并发、多线程同时争抢锁                        | 基于操作系统 **Mutex Lock（互斥锁）**，涉及线程挂起与唤醒 |   3. 锁升级流程      1. ```java         无锁状态            ↓ （第一次被线程访问，且没有竞争）         偏向锁（Biased Lock）            ↓ （当有第二个线程尝试获取锁，发现不是自己）         轻量级锁（Lightweight Lock，通过 CAS 自旋）            ↓ （如果自旋超过阈值，或等待线程较多，竞争激烈）         重量级锁（Heavyweight Lock，线程进入阻塞，由 OS 管理）\n\n\n线程1第一次获取锁\n       ↓\n     偏向锁（记录线程1的ID，几乎无开销）\n       ↓\n线程2来尝试获取锁（不是线程1）\n       ↓\n   偏向锁撤销，升级为轻量级锁\n       ↓\n线程1释放，线程2通过 CAS 获取锁（自旋）\n       ↓\n如果自旋多次仍失败，或竞争激烈\n       ↓\n     升级为重量级锁（线程阻塞，OS 管理）\n   4. 自旋：      1. 当一个线程尝试获取某个资源（比如锁）失败时，它不会立即被阻塞（挂起）、让出 CPU，而是通过循环（忙等 / busy-waiting）的方式，不停地尝试重新获取锁，直到成功为止。      2. 简单来说就是：线程不放弃 CPU，而是“原地打转”，反复尝试，直到成功获取所需资源。#### ReentrantLock1. 用法   1. 创建：`private final Lock lock = new ReentrantLock();`   2. 在访问共享资源之前，调用 `lock.lock()`加锁。这个方法会阻塞线程，直到加到锁。   3. 执行你的临界区代码（操作共享资源）   4. **在 finally 块中调用 `lock.unlock()`释放锁**（⚠️ 必须做，防止遇到**异常**导致无法解锁）   5. `trylock()`会尝试枷锁，不会阻塞线程。加到锁返回true，否则返回false。   6. 例子   ```java    // 加锁保证线程安全    public void add() &#123;        lock.lock();      // 1. 加锁        try &#123;            count++;      // 2. 临界区代码（操作共享资源）        &#125; finally &#123;            lock.unlock(); // 3. 一定要在 finally 中解锁        &#125;    &#125;\n\n\n\n\n作用范围是从lock到unlock的中间代码块\n\n\n\n公平锁和非公平锁\n1. \n\n\n\n\n特性\n公平锁（Fair Lock）\n非公平锁（Nonfair Lock）\n\n\n\n定义\n按照线程请求锁的 先后顺序 获取锁，先到先得\n线程获取锁时，不排队，直接尝试抢锁，谁抢到算谁的\n\n\n是否排队\n✅ 按 FIFO（先进先出）顺序获取锁\n❌ 不保证顺序，允许插队\n\n\n可能导致饥饿\n❌ 不会，所有线程最终都能获得锁\n✅ 可能，某些线程可能一直抢不到锁\n\n\n吞吐量（性能）\n⬇️ 较低，因为要维护顺序\n⬆️ 较高，减少线程切换和等待\n\n\n实现方式\n加锁前先检查是否有线程在排队\n直接尝试 CAS 抢锁，抢不到再排队\n\n\n创建方式\nnew ReentrantLock(true)\nnew ReentrantLock(false)或默认\n\n\n\n底层原理\n\nReentrantLock的公平与非公平实现，核心都依赖于 AQS（AbstractQueuedSynchronizer，抽象队列同步器）。\n\nAQS 的核心机制\nAQS 内部维护了一个 FIFO 等待队列（CLH 队列），以及一个 volatile 状态变量 state 表示锁的状态：\n\nstate &#x3D; 0：表示锁未被占用\nstate &gt; 0：表示锁被占用，数值代表重入次数\n\n当线程尝试获取锁时：\n\n如果锁是空闲的（state &#x3D;&#x3D; 0），尝试通过 CAS（Compare And Swap） 抢锁\n如果锁被占用，线程进入等待队列中排队\n\n\n非公平锁（Nonfair Lock）的实现原理\n\n获取锁时的逻辑（简化）：\n直接尝试 CAS 抢锁（不排队！）使用 CAS 将 state 从 0 改为 1，如果成功，当前线程获得锁\n如果 CAS 失败（锁被占用），才进入 AQS 队列等待\n唤醒后继续尝试抢锁\n\n\n优点：吞吐量高，减少线程挂起和切换，性能更好\n缺点：可能导致某些线程一直抢不到锁（饥饿）\n\n\n公平锁（Fair Lock）的实现原理\n\n获取锁时的逻辑（简化）：\n先检查是否有线程在排队（hasQueuedPredecessors()）如果队列中 已经有其它线程在等待，那么当前线程 不去抢锁，直接进入队列排队\n如果队列为空，才尝试 CAS 抢锁\n如果 CAS 成功，获得锁；失败则进入队列\n\n\n优点：避免饥饿，每个线程最终都能获得锁，公平性好\n缺点：性能较差，增加了线程切换和排队时间\n\n\n\n\n\n\n\nCountDownLatch\n倒计时门闩：CountDownLatch 是一个同步辅助类，它允许一个或多个线程等待，直到其他线程完成一组操作。你可以把它想象成一个“倒计时器”：主线程等待 N 个子线程完成各自任务后，再继续执行。\n工作原理\nCountDownLatch内部基于 AQS 实现\n初始化时设置一个 state &#x3D; count（计数值）\n每调用一次 countDown()，state 减 1（通过 CAS 操作）\n调用 await()的线程会阻塞，直到 state &#x3D;&#x3D; 0\nCountDownLatch 只能用一次，计数归零后不能重置！\n\n\n\nSemaphore\nSemaphore 是一个计数信号量，用于控制同时访问某个资源的线程数量，常用于限流、资源池管理。\n工作原理\nSemaphore也基于 AQS 实现\n内部维护了一组 可用的许可（permits），也就是 state 值\n调用 acquire()时：如果还有许可（state &gt; 0），则 state 减 1，线程继续执行如果没有许可，则线程进入 AQS 队列等待\n调用 release()时：state 加 1，唤醒等待队列中的一个线程\nSemaphore 可以重复使用，许可可以动态获取和释放\n\n\n\n网络编程基本的通信架构\nCS架构（Client客户端 &#x2F; Server服务端）\nBS架构（Browser浏览器 &#x2F; Server服务端）\n\nIPInetAddress\n是JAVA中的一个类，用于表示 IP 地址（可以是 IPv4 或 IPv6），并提供了与 IP 地址相关的一些常用操作，比如解析主机名、获取本机地址等\n\n常用方法\n\n\n\n\n\n方法\n说明\n\n\n\nstatic InetAddress getByName(String host)\n根据主机名（如 &quot;www.baidu.com&quot;）或 IP 地址字符串（如 &quot;14.215.177.39&quot;）返回对应的 InetAddress实例。\n\n\nstatic InetAddress[] getAllByName(String host)\n返回与给定主机名关联的所有 IP 地址（因为一个域名可能对应多个 IP）。返回的是一个数组。\n\n\nstatic InetAddress getLocalHost()\n获取本机（localhost）的 InetAddress对象。\n\n\nString getHostName()\n获取此 IP 地址对应的主机名。\n\n\nString getHostAddress()\n获取该对象的 IP 地址字符串表示（如 &quot;192.168.1.100&quot;）。\n\n\nboolean isReachable(int timeout)\n测试该地址是否可达（通过网络 ping），timeout 是超时时间（毫秒）。注意：这个方法不一定在所有环境下都有效，比如受防火墙限制。\n\n\nPort\n周知窗口：0-1023\n注册端口：1024-49151\n动态端口：49152-65535\n\n通信协议UDP协议\n特点：无连接，不可靠\n不事先建立连接。发出去就不管了\n每次把数据封装在包内（lim 64KB）\n\nTCP协议\n面向连接，可靠通信\n三次握手，四次挥手\n\nUDP通信DatagramSocket 、DatagramPacket\nDatagramSocket用于收发数据报\n\nDatagramPacket表示一个实际的数据包包括数据内容，目标IP和端口，来源IP和端口。\n\n常用方法\n\n\n\n\nDatagramSocket()\n创建一个 UDP 套接字，系统自动分配端口（常用于客户端）\n\n\n\nDatagramSocket(int port)\n创建并绑定到指定端口（常用于服务端）\n\n\nvoid send(DatagramPacket p)\n发送一个数据报包\n\n\nvoid receive(DatagramPacket p)\n接收一个数据报包（阻塞）\n\n\nvoid close()\n关闭套接字，释放资源\n\n\nvoid setSoTimeout(int timeout)\n设置接收超时时间（毫秒）\n\n\nint getLocalPort()\n获取本地绑定的端口号\n\n\nboolean isBound()\n是否已绑定端口\n\n\nboolean isClosed()\n是否已关闭\n\n\n\n\n\n\njava.net.Socket\n常用方法\n1. \n\n\n\n\nSocket(String host, int port)\n创建 Socket 并连接到指定主机和端口\n\n\n\nInputStream getInputStream()\n获取输入流，用于读取服务器数据\n\n\nOutputStream getOutputStream()\n获取输出流，用于向服务器发送数据\n\n\nvoid close()\n关闭 Socket 和相关资源\n\n\nvoid setSoTimeout(int timeout)\n设置读取超时（毫秒）\n\n\nInetAddress getInetAddress()\n获取远程服务器 IP\n\n\nint getPort()\n获取远程服务器端口\n\n\nboolean isConnected()\n判断是否已连接\n\n\nboolean isClosed()\n判断是否已关闭\n\n\n\n\n\n\njava.net.ServerSocket","categories":["java"],"tags":["test"]},{"title":"Hello World","url":"/2025/11/26/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"}]